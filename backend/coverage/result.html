
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>schemas: Go Coverage Report</title>
    <style>
        body {
            background: black;
            color: rgb(80, 80, 80);
        }

        body, pre, #legend span {
            font-family: Menlo, monospace;
            font-weight: bold;
        }

        #topbar {
            background: black;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 42px;
            border-bottom: 1px solid rgb(80, 80, 80);
        }

        #content {
            margin-top: 50px;
        }

        #nav, #legend {
            float: left;
            margin-left: 10px;
        }

        #legend {
            margin-top: 12px;
        }

        #nav {
            margin-top: 10px;
        }

        #legend span {
            margin: 0 5px;
        }

        .cov0 {
            color: rgb(192, 0, 0)
        }

        .cov1 {
            color: rgb(128, 128, 128)
        }

        .cov2 {
            color: rgb(116, 140, 131)
        }

        .cov3 {
            color: rgb(104, 152, 134)
        }

        .cov4 {
            color: rgb(92, 164, 137)
        }

        .cov5 {
            color: rgb(80, 176, 140)
        }

        .cov6 {
            color: rgb(68, 188, 143)
        }

        .cov7 {
            color: rgb(56, 200, 146)
        }

        .cov8 {
            color: rgb(44, 212, 149)
        }

        .cov9 {
            color: rgb(32, 224, 152)
        }

        .cov10 {
            color: rgb(20, 236, 155)
        }

    </style>
</head>
<body>
<div id="topbar">
    <div id="nav">
        <select id="files">

            <option value="file0">polimane/backend/repository/schemas/by_id.go (100.0%)</option>

            <option value="file1">polimane/backend/repository/schemas/by_user.go (100.0%)</option>

            <option value="file2">polimane/backend/repository/schemas/client.go (100.0%)</option>

            <option value="file3">polimane/backend/repository/schemas/copy.go (100.0%)</option>

            <option value="file4">polimane/backend/repository/schemas/create.go (100.0%)</option>

            <option value="file5">polimane/backend/repository/schemas/delete.go (100.0%)</option>

            <option value="file6">polimane/backend/repository/schemas/update.go (100.0%)</option>

        </select>
    </div>
    <div id="legend">
        <span>not tracked</span>

        <span class="cov0">no coverage</span>
        <span class="cov1">low coverage</span>
        <span class="cov2">*</span>
        <span class="cov3">*</span>
        <span class="cov4">*</span>
        <span class="cov5">*</span>
        <span class="cov6">*</span>
        <span class="cov7">*</span>
        <span class="cov8">*</span>
        <span class="cov9">*</span>
        <span class="cov10">high coverage</span>

    </div>
</div>
<div id="content">
		
		<pre class="file" id="file0" style="display: none">package schemas

import (
        "context"

        "polimane/backend/model"
)

type ByIDOptions struct {
        Ctx      context.Context
        User     *model.User
        SchemaID model.ID
        Select   []string
}

func (c *Impl) ByID(options *ByIDOptions) (*model.Schema, error) <span class="cov10" title="9">{
        var err error

        err = c.userSchemas.HasAccess(options.Ctx, options.User.ID, options.SchemaID)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov8" title="7">query := c.db.WithContext(options.Ctx)

        if len(options.Select) &gt; 0 </span><span class="cov3" title="2">{
                query = query.Select(options.Select)
        }</span>

        <span class="cov8" title="7">var schema model.Schema
        err = query.Take(&amp;schema, options.SchemaID).Error
        return &amp;schema, err</span>
}
</pre>

    <pre class="file" id="file1" style="display: none">package schemas

import (
        "context"

        "polimane/backend/model"
)

type ByUserOptions struct {
        Ctx    context.Context
        User   *model.User
        Select []string
}

func (c *Impl) ByUser(options *ByUserOptions) ([]*model.Schema, error) <span class="cov10" title="3">{
        query := c.db.
                WithContext(options.Ctx).
                Joins("JOIN user_schemas ON user_schemas.schema_id = schemas.id AND user_schemas.user_id = ?", options.User.ID)

        if len(options.Select) &gt; 0 </span><span class="cov1" title="1">{
                query = query.Select(options.Select)
        }</span>

        <span class="cov10" title="3">var schemas []*model.Schema
        err := query.Find(&amp;schemas).Error
        return schemas, err</span>
}
</pre>

    <pre class="file" id="file2" style="display: none">package schemas

import (
        "go.uber.org/fx"
        "gorm.io/gorm"

        "polimane/backend/model"
        repositoryuserschemas "polimane/backend/repository/userschemas"
        "polimane/backend/signal"
)

type Client interface {
        ByID(options *ByIDOptions) (*model.Schema, error)
        ByUser(options *ByUserOptions) ([]*model.Schema, error)
        Copy(options *CopyOptions) (*model.Schema, error)
        Create(options *CreateOptions) (schema *model.Schema, err error)
        Delete(options *DeleteOptions) (err error)
        Update(options *UpdateOptions) (err error)
}

type ClientOptions struct {
        fx.In
        DB          *gorm.DB
        UserSchemas repositoryuserschemas.Client
        Signals     *signal.Container
}

type Impl struct {
        db          *gorm.DB
        userSchemas repositoryuserschemas.Client
        signals     *signal.Container
}

var _ Client = (*Impl)(nil)

func Provider(options ClientOptions) Client <span class="cov8" title="1">{
        return &amp;Impl{
                db:          options.DB,
                userSchemas: options.UserSchemas,
                signals:     options.Signals,
        }
}</span>
</pre>

    <pre class="file" id="file3" style="display: none">package schemas

import (
        "context"
        "regexp"
        "strconv"
        "strings"

        "polimane/backend/model"
)

type CopyOptions struct {
        Ctx      context.Context
        User     *model.User
        SchemaID model.ID
}

var nameCopyCounter = regexp.MustCompile(`\((\d+)\)$`)

func makeCopyName(originalName string) string <span class="cov10" title="5">{
        counterMatch := nameCopyCounter.FindStringSubmatch(originalName)
        if len(counterMatch) == 0 </span><span class="cov7" title="3">{
                return originalName + " (1)"
        }</span>
        <span class="cov4" title="2">counter, _ := strconv.Atoi(counterMatch[1])
        counterStr := strconv.Itoa(counter + 1)
        return strings.ReplaceAll(originalName, counterMatch[0], " ("+counterStr+")")</span>
}

func (c *Impl) Copy(options *CopyOptions) (*model.Schema, error) <span class="cov4" title="2">{
        original, err := c.ByID(&amp;ByIDOptions{
                Ctx:      options.Ctx,
                SchemaID: options.SchemaID,
                User:     options.User,
        })

        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return c.Create(&amp;CreateOptions{
                Ctx:     options.Ctx,
                User:    options.User,
                Name:    makeCopyName(original.Name),
                Palette: original.Palette,
                Content: original.Content,
        })</span>
}
</pre>

    <pre class="file" id="file4" style="display: none">package schemas

import (
        "context"

        "gorm.io/gorm"

        "polimane/backend/model"
)

type CreateOptions struct {
        Ctx     context.Context
        User    *model.User
        Name    string
        Palette model.SchemaPalette
        Content model.SchemaContent
}

func (c *Impl) Create(options *CreateOptions) (schema *model.Schema, err error) <span class="cov10" title="4">{
        if options.Palette == nil </span><span class="cov5" title="2">{
                options.Palette = make(model.SchemaPalette, model.SchemaPaletteSize)
        }</span>

        <span class="cov10" title="4">if options.Content == nil </span><span class="cov5" title="2">{
                options.Content = make(model.SchemaContent, 0)
        }</span>

        <span
            class="cov10"
            title="4"
        >err = c.db.WithContext(options.Ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov10" title="4">{
                schema = &amp;model.Schema{
                        Name:    options.Name,
                        Palette: options.Palette,
                        Content: options.Content,
                }

                if err = tx.Create(schema).Error; err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov8" title="3">return c.userSchemas.CreateTx(tx, options.User.ID, schema.ID)</span>
        })

        <span class="cov10" title="4">if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">c.signals.InvalidateUserCache.Emit(options.Ctx, options.User.ID)
        return schema, nil</span>
}
</pre>

    <pre class="file" id="file5" style="display: none">package schemas

import (
        "context"

        "gorm.io/gorm"

        "polimane/backend/model"
)

type DeleteOptions struct {
        Ctx      context.Context
        User     *model.User
        SchemaID model.ID
}

func (c *Impl) Delete(options *DeleteOptions) (err error) <span class="cov10" title="6">{
        err = c.userSchemas.HasAccess(options.Ctx, options.User.ID, options.SchemaID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span
            class="cov9"
            title="5"
        >err = c.db.WithContext(options.Ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov9" title="5">{
                if err = tx.Delete(&amp;model.Schema{}, options.SchemaID).Error; err != nil </span><span
            class="cov1"
            title="1"
        >{
                        return err
                }</span>

                <span class="cov7" title="4">return c.userSchemas.DeleteTx(tx, options.User.ID, options.SchemaID)</span>
        })

        <span class="cov9" title="5">if err != nil </span><span class="cov6" title="3">{
                return err
        }</span>

        <span class="cov4" title="2">c.signals.InvalidateUserCache.Emit(options.Ctx, options.User.ID)
        return nil</span>
}
</pre>

    <pre class="file" id="file6" style="display: none">package schemas

import (
        "context"

        "polimane/backend/model"
)

type UpdateOptions struct {
        Ctx      context.Context
        User     *model.User
        SchemaID model.ID
        Updates  *model.Schema
}

func (c *Impl) Update(options *UpdateOptions) (err error) <span class="cov10" title="4">{
        err = c.userSchemas.HasAccess(options.Ctx, options.User.ID, options.SchemaID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="3">return c.db.
                WithContext(options.Ctx).
                Model(&amp;model.Schema{
                        Identifiable: &amp;model.Identifiable{
                                ID: options.SchemaID,
                        },
                }).
                Updates(options.Updates).
                Error</span>
}
</pre>

</div>
</body>
<script>
    (function () {
        var files = document.getElementById('files');
        var visible;
        files.addEventListener('change', onChange, false);

        function select(part) {
            if (visible)
                visible.style.display = 'none';
            visible = document.getElementById(part);
            if (!visible)
                return;
            files.value = part;
            visible.style.display = 'block';
            location.hash = part;
        }

        function onChange() {
            select(files.value);
            window.scrollTo(0, 0);
        }

        if (location.hash != '') {
            select(location.hash.substr(1));
        }
        if (!visible) {
            select('file0');
        }
    })();
</script>
</html>
